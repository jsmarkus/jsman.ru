---
title: Миграция с Express 2.x на Express 3.x
layout: post
comments: 1
published: false
---

## Удалено

  - `res.render()` опция "status" (используйте `res.statusCode=` или `res.status(code).render(...)`)
  - `res.render()` опция "charset" (используйте `res.charset=`)
  - `res.local(name, value)` (используйте `res.locals.name = value` или `res.locals({ name: value })`)
  - `app.dynamicHelpers()` (используйте middleware + `res.locals`)
  - `app.helpers()` (используйте `app.locals`)
  - концепция "layout" (теперь это задача шаблонизатора)
  - `partial()` (теперь это задача шаблонизатора)
  - `res.partial()`
  - настройка "view options", используйте `app.locals`
  - настройка "hints"
  - `req.isXMLHttpRequest` (используйте `req.xhr`)
  - `app.error()` (используйте middleware с аргументами (err, req, res, next))
  - `req.flash()` (просто используйте сессии: `req.session.messages = ['foo']` или как-то так)
  - [connect-flash](https://github.com/jaredhanson/connect-flash) может иисполльзоваться вместо req.flash()
  - настройка `jsonp callback` была удалена (используйте `res.jsonp()`)

## Изменилось

  - `req.header(field[, defaultValue])` изменили на `req.get(field)` (оставлено для обратной совместимости)
  - `res.header(field[, value])` изменили на `res.set(field, value)` / `res.get(field)` (оставлено для обратной совместимости)
  - переименовали `app.register()` на `app.engine()`
  - шаблонизатор теперь должен соответствовать не `engine.compile(str, options) => Function`, а `engine.__express(filename, options, callback)`
  - `express.createServer()` теперь просто `express()` (но для обратной совместимости сохранено). 
    - помните, что `express()` теперь __не возвращает экземпляр `http.Server`__. (См. раздел **Application function**, там детальнее)
  - Используйте `express.cookieParser('secret')` вместо того, чтобы передавать "секрет" в middleware `express.session()`. Опция 'secret' в middleware `express.session()` была удалена.

## View options

  Настройка "view options" больше не нужна, `app.locals` - это локальные переменные, которые смешиваются с теми, что мы передаём в `res.render()`, поэтому `app.locals.pretty = true` эквивалентно `res.render(view, { pretty: true })`.

## Application function

 `express()` теперь возвращает функцию, которая выполняет единичный такт приложения Express. Это значит, что можно легко создавать HTTP- и HTTPS-версии приложения, передавая эту функцию в стандартные нодовские методы `http.createServer()` и `https.createServer()`:

```js
...
var app = express();
http.createServer(app).listen(80);
https.createServer(options, app).listen(443);
```

 Для удобства и простоты метод `app.listen()` принимает те же аргументы,
 оборачивая их в HTTP сервер. Следующие примеры эквивалентны:

```js
var app = express();
app.listen(3000);
```

и

```js
var app = express()
  , http = require('http');

http.createServer(app).listen(3000);
```

Это означает, что методы, присутствующие в `http.Server.prototype`, более не присутствуют в `app`, например, `app.address()` теперь должен вызываться у экземпляра сервера, который возвращается из `app.listen()`
или того, который вы создадите с помощью `http.createServer(app)`.

## Socket.IO compatibility

Socket.IO's `.listen()` method takes an `http.Server` instance as an argument. As of 3.x, the return value of `express()` is not an `http.Server` instance. (See the **Application function** section above.) To get Socket.IO working with Express 3.x, make sure you manually create and pass your `http.Server` instance to Socket.IO's `.listen()` method.

```js
var app = express()
  , http = require('http')
  , server = http.createServer(app)
  , io = require('socket.io').listen(server);

server.listen(3000);
```

## Template engine integration

 Express 2x template engine compatibility required the following module export:

```js
exports.compile = function(templateString, options) {
  return a Function;
};
```

  Express 3x template engines should export the following:

```js
exports.__express = function(filename, options, callback) {
  callback(err, string);
};
```

  If a template engine does not expose this method, you're not out of luck, the `app.engine()` method allows you to map any function to an extension. Suppose you had a markdown library and wanted to render `.md` files, but this library did not support Express, your `app.engine()` call may look something like this:

```js
var markdown = require('some-markdown-library');

app.engine('md', function(path, options, fn){
  fs.readFile(path, 'utf8', function(err, str){
    if (err) return fn(err);
    str = markdown.parse(str).toString();
    fn(null, str);
  });
});
```

## View system changes

 By removing the concept of a "layout" & partials in Express 3.x template engines
 will have greater control over file I/O. This means integration with template engines
 much easier, and greatly simplify the view system's internals.

 This also enables template engines to supply their own means of inheritance, for example later releases of Jade provide Django-inspired template inheritance, where the view being rendered specifies the layout it wants to extend. For an example of this using the Jade engine visit [http://www.devthought.com/code/use-jade-blocks-not-layouts/](http://www.devthought.com/code/use-jade-blocks-not-layouts/)

 Post-release we may end up building an Express extension to support the old `partial()` concept.

 To get back layout functionality with EJS you can use [express-partials](https://github.com/publicclass/express-partials) or [ejs-locals](https://github.com/RandomEtc/ejs-locals).

## Error handling middleware

  The `app.error(callback)` method in 2.x was effectively the same as the following:

```js
app.error = function(fn){
  this.use(function(err, req, res, next){
    fn.apply(this, arguments);
  });
};
```

 The reason for this is that Connect differentiates between "regular" middleware,
and "error-handling" middleware via the `fn.length`. A regular middleware has a `fn.length`
of `<= 3`, aka `(req, res, next)`, whereas error-handling middleware must have exactly `4` `(err, req, res, next)`. So the reason 2.x wrapped this functionality was to simply provide a bit of sugar on-top of this
API making the parameters optional.

 In short all you need to do to "catch" these errors that are passed along is to define another middleware, but with `4` arguments. Note that this middleware should be defined _below_ all the others, so that they may invoke `next(err)` in order to pass an error to it like so:

```js
app.use(express.bodyParser())
app.use(express.cookieParser())
app.use(express.session())
app.use(app.router) // the router itself (app.get(), app.put() etc)
app.use(function(err, req, res, next){
  // if an error occurs Connect will pass it down
  // through these "error-handling" middleware
  // allowing you to respond however you like
  res.send(500, { error: 'Sorry something bad happened!' });
})
``` 

## App- & Request-level local variables

 .. todo