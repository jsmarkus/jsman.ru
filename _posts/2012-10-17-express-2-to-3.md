---
title: Миграция с Express 2.x на Express 3.x
layout: post
comments: 1
published: false
---

## Удалено

  - `res.render()` опция "status" (используйте `res.statusCode=` или `res.status(code).render(...)`)
  - `res.render()` опция "charset" (используйте `res.charset=`)
  - `res.local(name, value)` (используйте `res.locals.name = value` или `res.locals({ name: value })`)
  - `app.dynamicHelpers()` (используйте middleware + `res.locals`)
  - `app.helpers()` (используйте `app.locals`)
  - концепция "layout" (теперь это задача шаблонизатора)
  - `partial()` (теперь это задача шаблонизатора)
  - `res.partial()`
  - настройка "view options", используйте `app.locals`
  - настройка "hints"
  - `req.isXMLHttpRequest` (используйте `req.xhr`)
  - `app.error()` (используйте middleware с аргументами (err, req, res, next))
  - `req.flash()` (просто используйте сессии: `req.session.messages = ['foo']` или как-то так)
  - [connect-flash](https://github.com/jaredhanson/connect-flash) может иисполльзоваться вместо req.flash()
  - настройка `jsonp callback` была удалена (используйте `res.jsonp()`)

## Изменилось

  - `req.header(field[, defaultValue])` изменили на `req.get(field)` (оставлено для обратной совместимости)
  - `res.header(field[, value])` изменили на `res.set(field, value)` / `res.get(field)` (оставлено для обратной совместимости)
  - переименовали `app.register()` на `app.engine()`
  - шаблонизатор теперь должен соответствовать не `engine.compile(str, options) => Function`, а `engine.__express(filename, options, callback)`
  - `express.createServer()` теперь просто `express()` (но для обратной совместимости сохранено). 
    - помните, что `express()` теперь __не возвращает экземпляр `http.Server`__. (См. раздел **Application function**, там детальнее)
  - Используйте `express.cookieParser('secret')` вместо того, чтобы передавать "секрет" в middleware `express.session()`. Опция 'secret' в middleware `express.session()` была удалена.

## View options

  Настройка "view options" больше не нужна, `app.locals` - это локальные переменные, которые смешиваются с теми, что мы передаём в `res.render()`, поэтому `app.locals.pretty = true` эквивалентно `res.render(view, { pretty: true })`.

## Application function

 `express()` теперь возвращает функцию, которая выполняет единичный такт приложения Express. Это значит, что можно легко создавать HTTP- и HTTPS-версии приложения, передавая эту функцию в стандартные нодовские методы `http.createServer()` и `https.createServer()`:

```js
...
var app = express();
http.createServer(app).listen(80);
https.createServer(options, app).listen(443);
```

 Для удобства и простоты метод `app.listen()` принимает те же аргументы,
 оборачивая их в HTTP сервер. Следующие примеры эквивалентны:

```js
var app = express();
app.listen(3000);
```

и

```js
var app = express()
  , http = require('http');

http.createServer(app).listen(3000);
```

Это означает, что методы, присутствующие в `http.Server.prototype`, более не присутствуют в `app`, например, `app.address()` теперь должен вызываться у экземпляра сервера, который возвращается из `app.listen()`
или того, который вы создадите с помощью `http.createServer(app)`.

## Совместимость с Socket.IO

Метод `.listen()` Socket.IO принимает аргументом экземпляр `http.Server`. С версии 3.x, `express()` не возвращает экземпляр `http.Server`. (См. раздел **Application function** выше.) Чтобы Socket.IO заработал с Express 3.x, создайте вручную и передайте экземпляр `http.Server` в метод `.listen()` Socket.IO.

>>> Примечание переводчика. Я, например, передаю в Socket.IO то, что вернуло мне `app.listen()`, это ведь тоже `http.Server`

```js
var app = express()
  , http = require('http')
  , server = http.createServer(app)
  , io = require('socket.io').listen(server);

server.listen(3000);
```

## Интеграция шаблонизаторов

 Для совместимости с Express 2.x шаблонизатор должен экспортировать следущее:

```js
exports.compile = function(templateString, options) {
  return a Function;
};
```

  Совместимые с Express 3.x шалонизаторы должны экспортировать следующее:

```js
exports.__express = function(filename, options, callback) {
  callback(err, string);
};
```

Если шаблонизатор не экспортирует этот метод, все равно есть способ - метод `app.engine()` позволяет сопоставить любую функцию определённому расширению файла.
Допустим, есть библиотека markdown, и нужно рендерить `.md`-файлы, но эта библиотека не поддерживает Express, тогда ваш вызов `app.engine()` будет выглядеть примерно так:

```js
var markdown = require('some-markdown-library');

app.engine('md', function(path, options, fn){
  fs.readFile(path, 'utf8', function(err, str){
    if (err) return fn(err);
    str = markdown.parse(str).toString();
    fn(null, str);
  });
});
```

## Изменения системы шаблонов

После удаления концепции layouts и partials в Express 3.x шаблонизаторы теперь имеют больше контроля над операциями файлового ввода-вывода. Интеграция с шаблонизаторами теперь существенно упростилась, также упростились внутренние механизмы системы шаблонов.

Это позволяет шаблонизаторам использовать собственные средства наследования, например, последние версии Jade идут с Django-образным наследованием шаблонов (шаблон может указывать от какого шаблона он наследуется). Пример: [http://www.devthought.com/code/use-jade-blocks-not-layouts/](http://www.devthought.com/code/use-jade-blocks-not-layouts/)

 Post-release we may end up building an Express extension to support the old `partial()` concept.

 To get back layout functionality with EJS you can use [express-partials](https://github.com/publicclass/express-partials) or [ejs-locals](https://github.com/RandomEtc/ejs-locals).

## Error handling middleware

  The `app.error(callback)` method in 2.x was effectively the same as the following:

```js
app.error = function(fn){
  this.use(function(err, req, res, next){
    fn.apply(this, arguments);
  });
};
```

 The reason for this is that Connect differentiates between "regular" middleware,
and "error-handling" middleware via the `fn.length`. A regular middleware has a `fn.length`
of `<= 3`, aka `(req, res, next)`, whereas error-handling middleware must have exactly `4` `(err, req, res, next)`. So the reason 2.x wrapped this functionality was to simply provide a bit of sugar on-top of this
API making the parameters optional.

 In short all you need to do to "catch" these errors that are passed along is to define another middleware, but with `4` arguments. Note that this middleware should be defined _below_ all the others, so that they may invoke `next(err)` in order to pass an error to it like so:

```js
app.use(express.bodyParser())
app.use(express.cookieParser())
app.use(express.session())
app.use(app.router) // the router itself (app.get(), app.put() etc)
app.use(function(err, req, res, next){
  // if an error occurs Connect will pass it down
  // through these "error-handling" middleware
  // allowing you to respond however you like
  res.send(500, { error: 'Sorry something bad happened!' });
})
``` 

## App- & Request-level local variables

 .. todo